## 2.2.2 顺序分配

- 性质：`LOC(X[j+1]) = LOC(X[j]) + c`，`LOC(X[j]) = L0 + cj`
- 栈：维持一个栈指针T
- （双端）队列：维持两个指针F和R（表示队列的前端和后端）
  - 浪费空间：把节点排成环
  - 没考虑溢出：考虑溢出
  - 溢出时做什么
    - UNDERFLOW：看作一个有意义的条件而非一个错误
    - OVERFLOW：一个错误
- 怎么避免OVERFLOW
  - 如果有两个表，可以彼此相向地增长
  - 如果有多个表，需要允许基地址改变位置
- 对于栈来说，维持一个BASE链接变量数组和一个TOP链接变量数组即可。如果发生溢出，可以重新组装存储器，从还未填满的表中腾出空间给已经溢出的表。
  - 朴素的方法：开始所有栈的BASE和TOP都位于$L_0$处，先考虑上移上面的栈，再考虑下移下面的栈。如果都找不到则放弃。
  - 改进：平均分配BASE和TOP于$L_0$和$L_\infty$之间。
  - 改进：出现溢出时，基于自上次存储重装以来每个栈的大小变化，对存储器进行完全的重装。

### 习题

> 1

M - 1项。

> 2

从后端删除：

1. 如果F = R，则UNDERFLOW。
2. Y <- X[R]。
3. 如果R = 1，则R <- M，否则R <- R - 1。

从前端插入：

1. X[F] <- Y。
2. 如果F = 1，则F <- M，否则F <- F - 1。
3. 如果F = R，则OVERFLOW。

> 6

(c)会上溢，(e)会下溢。

> 7

不会。在算法G发生之前，TOP[i]已经增大了，所以至少有一个增长。

> 16

两个队列可以，同向放置。一个栈和一个队列不行。

> 19

非常简单。

