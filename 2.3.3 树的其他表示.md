## 2.3.3 树的其他表示

- 先根序顺序表示
  - 按先根序顺序排列所有节点。
  - 每个节点有RLINK字段，指向右儿子；有LTAG字段，表明是不是终节点。如果不是终节点，LLINK实际上指向下一项。
  - 实际上可以只需要RTAG和LTAG，从而推断出RLINK，但这需要花费时间。
  - RLINK有很多浪费。
    - 以在该节点之下在子树之后的地址来填入每个节点的RLINK。
    - 删去RLINK字段，并在原先有非空RLINK的节点紧前面添加特殊的“链接”节点。
- 家庭序顺序表示
- 层次序顺序表示
- 带度数的后根序

> 算法F（计算在树中局部定义的函数）假设f是树的节点的函数，使得在树的节点x处f的值仅仅依赖于x和x的儿子的f值。下列算法，利用辅助栈，计算在非空的森林中每个节点处的f。
>
> F1. [初始化] 置栈为空，并令P指向在后根序下的森林的头一个节点。
>
> F2. [计算f] 置d $\leftarrow$ DEGREE(P)。利用在栈上找到的$f(x_d), \cdots, f(x_1)$的值，计算f(NODE(P))。
>
> F3. [更新栈] 从栈上删去顶部的d个项；然后把值f(NODE(P))放入栈顶。
>
> F4. [前进] 如果P是后根序下的最后节点，则终止这个算法。否则置P为在后根序下它的后继，并返回到F2。

- 链接表示

  - 从所有的非终节点删去INFO字段，而把这个信息作为新的终节点放到以前节点的下面。
  - 使得所有INFO都出现于终节点中。
  - LLINK和INFO互相排斥，可以放在一个字段中。

- 例子：等价关系

  - 定义：一个等价关系“$\equiv$”是对于对象集合S中的任何对象x，y和z，满足以下三个性质的元素之间的关系：
    1. 如果$x \equiv y$且$y \equiv z$，则$x \equiv z$。（传递性）
    2. 如果$x \equiv y$，则$y \equiv x$。（对称性）
    3. $x \equiv x$。（反身性）

  > 算法E（处理等价关系）
  >
  > E1. [初始化] 对于$1 \le k \le n$，置PARENT[k] $\leftarrow$ 0。
  >
  > E2. [输入新的对] 从输入中得到下一对等价元素“$j \equiv k$”。若输入穷尽，算法结束。
  >
  > E3. [寻找根] 如果PARENT[j] > 0，则置j $\leftarrow$ PARENT[j]，并重复此步。如果PARENT[k] > 0，置k $\leftarrow$ PARENT[k]，并重复此步。
  >
  > E4. [合并树] 如果j ≠ k，置PARENT[j] $\leftarrow$ k，转回到步骤E2。

- 双重循环表示

- 例子：多项式加法

### 习题

> 1

可以。交换LTAG和RTAG、LLINK和RLINK，而且使用队列代替栈。

> 2

每次遇到0就退栈，遇到非0元素则减1，变为0则同样退栈。

> 4

正常方法需要n个LLINK和n个RLINK。

简单方法需要n-m个LLINK和2n-m个RLINK。

> 5

不用，会多余。

> 7

{1, 5}, {2, 3, 4, 7}, {6, 8, 9}

> 8

比较PARENT[j]和PARENT[k]即可。









